<!DOCTYPE html>
<head>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title>Hello, AR DROP!!</title>
	<!-- include three.js library -->
	<script src='three.js'></script>
	<!-- include jsartookit -->
	<script src="artoolkit.min.js"></script>
	<script src="artoolkit.api.js"></script>
	<!-- include threex.artoolkit -->
	<script src="threex-artoolkitsource.js"></script>
	<script src="threex-artoolkitcontext.js"></script>
	<script src="threex-arbasecontrols.js"></script>
	<script src="threex-armarkercontrols.js"></script>
</head>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>

<!-- 
  Example created by Lee Stemkoski: https://github.com/stemkoski
  Based on the AR.js library and examples created by Jerome Etienne: https://github.com/jeromeetienne/AR.js/
-->

<script>

         		var scene = new THREE.Scene();
			//var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			var camera = new THREE.Camera();
			scene.add(camera);

			var renderer = new THREE.WebGLRenderer({
			antialias : true,
			alpha: true
			});
			renderer.setClearColor(new THREE.Color('lightgrey'), 0)
			renderer.setSize( 640, 480 );
			renderer.domElement.style.position = 'absolute'
			renderer.domElement.style.top = '0px'
			renderer.domElement.style.left = '0px'
			document.body.appendChild( renderer.domElement );
			
			var a = 0.5;
			var b = 1;
			console.log(a);
			var parametricDrop = function(u, v, vector) {

				let v0 = v * Math.PI * 2;
				let u0 = u * Math.PI;

			vector.x = a * (b - Math.cos(u0)) * Math.sin(u0) * Math.cos(v0);
			vector.y = a * (b - Math.cos(u0)) * Math.sin(u0) * Math.sin(v0);
			vector.z = Math.cos(u0);
			};
			
			var geometry = new THREE.ParametricGeometry( parametricDrop, 25, 25 );
			var material = new THREE.MeshNormalMaterial( { wireframe: true} );
			var mesh = new THREE.Mesh( geometry, material ) ;
			//scene.add( mesh );
			camera.position.z = 5;

			var arToolkitSource = new THREEx.ArToolkitSource({
			sourceType : 'webcam',
			});

			function onResize()
			{
				arToolkitSource.onResize()	
				arToolkitSource.copySizeTo(renderer.domElement)	
				if ( arToolkitContext.arController !== null )
				{
					arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)	
				}	
			}

			arToolkitSource.init(function onReady(){
				onResize()
			});
			
			// handle resize event
			window.addEventListener('resize', function(){
				onResize()
			});
	

			var arToolkitContext = new THREEx.ArToolkitContext({
				cameraParametersUrl: 'camera_para.dat',
				detectionMode: 'mono'
			});
			
			// copy projection matrix to camera when initialization complete
			arToolkitContext.init( function onCompleted(){
				camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
			});

			// build markerControls
			var markerRoot1 = new THREE.Group();
			scene.add(markerRoot1);
			let markerControls1 = new THREEx.ArMarkerControls(arToolkitContext, markerRoot1, {
				type: 'pattern', patternUrl: "hiro.patt",
			})
	
	
			markerRoot1.add( mesh );


			function update()
			{
				// update artoolkit on every frame
				if ( arToolkitSource.ready !== false )
					arToolkitContext.update( arToolkitSource.domElement );
			}


			var animate = function () {
				requestAnimationFrame( animate );

				mesh.rotation.x += 0.01;
				mesh.rotation.y += 0.01;
				update();
				renderer.render( scene, camera );
			};

			animate();



</script>

</body>
</html>
